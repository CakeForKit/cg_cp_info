\chapter{Технологическая часть}

В данном разделе представлены средства реализации, листинги основных алгоритмов, описаны процесс сборки, интерфейс приложения и методы тестирования.

\section{Средства реализации}
В качестве языка программирования был выбран \texttt{C++}~\cite{cpp} в силу следующих причин:
\begin{itemize}
	\item В стандартной библиотеке языка присутствует поддержка всех структур данных, выбранных по результатам проектирования;
	\item Средствами языка можно реализовать все алгоритмы, выбранные в результате проектирования;
\end{itemize}

Для создания пользовательского интерфейса был использован фреймворк~\texttt{QT}~\cite{qt}, так как данный фреймворк предоставляет инструменты для создания пользовательских интерфейсов и поддерживается язык программирования~\texttt{C++}.

%Для сборки программного обеспечения использовалась утилита~\texttt{CMake}~\cite{cmake}, так как с ee помощью возможно управлять процессом компиляции и сборки проекта, написанного на \texttt{C++}.

Для модульного тестирования компонент программного обеспечения был выбран фреймворк~\texttt{GoogleTest}~\cite{gtest}, так как данный фреймворк предоставляет инструменты для написания модульных тестов на языке~\texttt{C++}.

Для определения покрытия кода использовалась утилита~\texttt{gcov}~\cite{gcov}.

\clearpage
\section{Реализации алгоритмов}
В листинге~\ref{lst:castRay} представлена реализация алгоритма определения цвета пикселя.

%\begin{center}
%	\captionsetup{justification=raggedright,singlelinecheck=off}
%	\renewcommand{\lstlistingname}{Листинг}
%	\begin{lstlisting}[label=lst:ray_tracing, caption=Реализация алгоритма обратной трассировки лучей]
%	void RayTracing::render() {
%		for (int j = 0; j < drawer->getImgHeight(); ++j) {
%			for (int i = 0; i < drawer->getImgWidth(); ++i) {
%				Ray ray = camera->createRay(i, j);
%				Intensity intens = castRay(ray);
%				drawer->setPixelColor(i, j, Color(intens));
%			}
%		}
%		drawer->setScene();
%	}
%	\end{lstlisting}
%\end{center}

\begin{center}
	\captionsetup{justification=raggedright,singlelinecheck=off}
	\renewcommand{\lstlistingname}{Листинг}
	\begin{lstlisting}[label=lst:castRay, caption=Реализация алгоритма определения цвета пикселя]
	Intensity StandardRayTracing::castRay(Ray &ray, const size_t depth, bool printing) const noexcept {
		if (!ray.getDirection().isNormalized())
		ray.getDirection().normalize();
		
		Intensity color(0, 0, 0);
		
		intersection_t intersect;
		if (scene->intersection(ray, intersect) && depth < maxDepth) {
			Point3 posLight;  
			Vector3 L;          
			intersection_t tmpIntersect;
			Vector3 diff, spec;
			double ddist;
			for (Scene::iteratorLight it = scene->beginLight(); it != scene->endLight(); ++it) {
				if ((*it)->getType() == typeLight::POINT) {
					L = (posLight - intersect.point).normalized();  
					
					if (fabs(intersect.normal.length()) < EPS) {
						return Intensity(1, 0, 0);
					}
					if (!intersect.normal.isNormalized())
					intersect.normal.normalize();
					double nL = L.scalarProduct(intersect.normal);  
					
					if (nL > 0 && !scene->intersection(Ray(intersect.point + 1e-3 * intersect.normal, L), tmpIntersect)) {
						
						diff = intersect.material->getKd() * nL;
						
						Vector3 reflectLight = L.reflect(intersect.normal);
						double SR = reflectLight.scalarProduct(-ray.getDirection());
						if (SR < 0)
						SR = 0;
						spec = intersect.material->getKs() * pow(SR, intersect.material->getN());
						
						ddist = (posLight - intersect.point).length() / (posLight.length() + EPS);
						if (ddist > 1.0)
						ddist = 1;
						else if (ddist < 0.4)
						ddist = 0.4;
						
						color += (diff + spec) * (*it)->getIntensity() / ddist;  
					}
					
				} else if ((*it)->getType() == typeLight::AMBIENT) {
					color += intersect.material->getKa() * (*it)->getIntensity();
				}
			}
			
			Vector3 reflectVec = ray.getDirection().reflect(intersect.normal);
			Ray reflectRay(intersect.point + 1e-3 * intersect.normal, reflectVec);
			Intensity reflectIntensity = castRay(reflectRay, depth + 1);

			color += intersect.material->getKs() * reflectIntensity;
		}
		else 
		color = Intensity(0.3, 0.3, 0.3);
		
		return color;
	}
	\end{lstlisting}
\end{center}
\clearpage


%\section{Описание процесса сборки приложения}
%Для сборки программного обеспечения использовалась утилита~\texttt{CMake}~\cite{cmake}. Для сборки приложения необходимо в командной строке, находясь в директории проекта, выполнить следующие команды~\ref{lst:build}.
%
%\begin{center}
%	\captionsetup{justification=raggedright,singlelinecheck=off}
%	\renewcommand{\lstlistingname}{Листинг}
%	\begin{lstlisting}[label=lst:build, caption=Сборка программного обеспечения]
%$ cd build
%$ cmake -S ..
%$ cmake -build .
%	\end{lstlisting}
%\end{center}
%\clearpage

\section{Описание интерфейса приложения}
На рисунках~\ref{img:interface_create}-\ref{img:interface_tab} представлен интерфейс программы. 

На рисунке~\ref{img:interface_create} представлена вкладка добавления фигуры определенного игрока из выпадающего списка на позицию шахматной доски, изменение цветового набора и изменения материала шахматной доски. На рисунке~\ref{img:interface_move} представлена вкладка изменения позиции и вращения модели с индексом, определенным на вкладке~\ref{img:interface_tab}. На рисунке~\ref{img:interface_camera} представлена вкладка изменения позиции и вращения камеры. На рисунке~\ref{img:interface_scene} представлена вкладка изменения содержимого сцены. На рисунке~\ref{img:interface_scene} представлена вывода информации о сцене.

\FloatBarrier
\imgw{0.5\textwidth}{interface_create}{Интерфейс программы. Вкладка добавления моделей и настроек материалов}
\FloatBarrier
\imgw{0.5\textwidth}{interface_move}{Интерфейс программы. Вкладка изменения позиции модели}
\FloatBarrier
\imgw{0.5\textwidth}{interface_camera}{Интерфейс программы. Вкладка изменения позиции камеры}
\FloatBarrier
\imgw{0.5\textwidth}{interface_scene}{Интерфейс программы. Вкладка настроек сцены}
\FloatBarrier
\imgw{0.5\textwidth}{interface_tab}{Интерфейс программы. Вкладка вывода информации о сцене}
\FloatBarrier

\clearpage
\section{Тестирование}

\subsection{Функциональное тестирование}
Для функционального тестирования была рассмотрена сцена, на которой изображены все виды фигур, и выделены следующие классы эквивалентности: камера расположена под углом $30^\circ$~(\ref{img:ft_3}); вид сбоку~(\ref{img:ft_2}); вид сверху~(\ref{img:ft_1}).
%\begin{itemize}
%	\item Камера расположена под углом $30^\circ$~(\ref{img:ft_3});
%	\item Вид сбоку~(\ref{img:ft_2});
%	\item Вид сверху~(\ref{img:ft_1});
%\end{itemize}

\FloatBarrier
\imgw{0.45\textwidth}{ft_3}{Камера расположена под углом $30^\circ$}
\FloatBarrier
\imgw{0.45\textwidth}{ft_2}{Вид сбоку}
\FloatBarrier
\imgw{0.45\textwidth}{ft_1}{Вид сверху}
\FloatBarrier

\subsection{Модульное тестирование}
Для модульного тестирования компонент программного обеспечения использовался фреймворк~\texttt{GoogleTest}~\cite{gtest}. 

Были созданы параметризованные тесты для функций классов: $Camera$, $RayTracing$, $Ray$ и $Triangle$. Для тестов каждого рассматриваемого объекта использовался класс фиксации, в котором производились настройки окружения, например создание классов $SceneManager$ и $MaterialManager$, в функции SetUp, а также освобождение памяти, при необходимости, в функции TearDown.


\subsection{Результаты тестирования}

В качестве меры полноты тестирования был выбран процент покрытия строк кода. Результаты тестирования, были обработаны утилитой~\texttt{lcov}~\cite{lcov} и представленный в таблице~\ref{tbl:resTest}:

\begin{longtable}{|
		>{\raggedright\arraybackslash}p{.25\textwidth - 2\tabcolsep}|
		>{\raggedright\arraybackslash}p{.25\textwidth - 2\tabcolsep}|
		>{\raggedright\arraybackslash}p{.25\textwidth - 2\tabcolsep}|
		>{\raggedright\arraybackslash}p{.25\textwidth - 2\tabcolsep}|
	}
	\caption{Результаты тестирования}\label{tbl:resTest} \\\hline
	 & Hit & Total & Coverage \\\hline
	\endfirsthead
	\caption*{Продолжение таблицы~\ref{tbl:log} } \\\hline
	 & Hit & Total & Coverage \\\hline \\\hline                    
	\endhead
	\endfoot
	Lines & 1080 & 3096 & 34.9 \% \\\hline
	Functions & 220 & 463 & 47.5 \% \\\hline
	
\end{longtable}

%\clearpage
\section*{Вывод из технологической части}
Было реализовано программное обеспечение и представлены средства реализации, листинги основных алгоритмов, описаны интерфейс приложения и методы тестирования.
\clearpage
