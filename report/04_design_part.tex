\chapter{Конструкторская часть}

В данном разделе представлены математические основы и схема алгоритма обратной трассировки лучей, функциональная модель и структура программного обеспечения. 
%Так же будут описаны используемые структуры данных и структура реализуемого программного обеспечения.


\section{Математические основы алгоритма обратной трассировки лучей}
\subsection{Определение пересечения луча с полигоном}
Так как любую плоскость можно однозначно задать тремя точками, для поиска пересечения луча с полигонами используется алгоритм Моллера~--~Трумбора~\cite{trIntersect}, с помощью которого можно вычислить пересечение луча с треугольным полигоном. Рассмотрим данн

Пусть треугольный полигон определен вершинами $V_0, V_1, V_2$, а луч $R(t)$ с началом в точке $O$ и единичным  вектором направления $D$ определен формулой
\begin{equation}
	R(t) = O + tD
\end{equation}

И если точку $T(u,v)$ на треугольнике $V_0V_1V_2$ выразить через ее барицентрические координаты $(u,v)$, так что ($u \geq 0, v \geq 0, u + v \leq 1$):
\begin{equation}
	T(u,v) = (1 - u - v)V_0 + uV_1 + vV_2,
\end{equation}
тогда пересечение луча $R(t)$ и треугольника $V_0V_1V_2$ эквивалентно решению уравнения
$R(t) = T(u, v)$ и однозначно определяются параметрами расстояния $t$ от начала луча до точки пересечения и барицентрическими координатами $(u,v)$. В таком случае получим:
\begin{equation}\label{eq:eq1}
	O + tD = (1- u - v)V_0 + uV_1 + vV_2
\end{equation}

Уравнение~\ref{eq:eq1} может быть представнено в матричном виде:
\begin{equation}
	\label{slau}
	\begin{bmatrix}
		-D & V_1 - V_0, V_2 - V_0
	\end{bmatrix}
	\begin{bmatrix}
		t\\
		u\\
		v
	\end{bmatrix} = O - V_0 
\end{equation}

Пусть $E_1 = V_1 - V_0, E_2 = V_2 - V_0$, $T=O - V_0$. Решение уравнения~\ref{eq:eq1} можно получить методом Крамера:
\begin{equation}\label{eq:eq2}
	\begin{bmatrix}
		t\\
		u\\
		v
	\end{bmatrix} = \frac{1}{(D\times E_2) \cdot E_1}
	\begin{bmatrix}
		(T\times E_1) \cdot E_2\\
		(D\times E_2) \cdot T\\
		(T\times E_1) \cdot D
	\end{bmatrix}
\end{equation}
 
Если баричентически координаты точки пересечения полученной из формулы~\ref{eq:eq2} удовлетворяют условию ($u \geq 0, v \geq 0, u + v \leq 1$), то луч $R(t)$ пересекает треугольный полигон заданный вершинами $V_0, V_1, V_2$. Если определитель $(D\times E_2) \cdot E_1$ равен нулю то луч лежит в плоскости треугольника $V_0V_1V_2$.


%\subsection{Определение нормали к плоскости}
%Нормаль к плоскости можно найти как векторное произведение двух векторов, принадлежащих данной плоскости~\cite{rodgersCG}:
%
%Для поиска нормали к полигонам необходимо найти векторное произведение двух векторов, которые лежат на полигоне \cite{rodgers}.
%\begin{equation}
%	N = (V_2 - V_0) \times (V_1 - V_0),
%\end{equation}
%где $V_0, V_1, V_2$ -- вершины полигона.

\subsection{Определение вектора отраженния}

Для визуализации отражающих поверхностей в алгоритме обратной трассировки лучей необходим способ определения направления вектора отражения зная луч падения~$l$ и нормаль к поверхности~$n$~\cite{rtOneWeekend}.

\imgw{0.4\textwidth}{reflect}{Расчет направления вектора отражения}

Вектор отражения представляется через разность вектора падения $l$ и вектора нормали $n$, длина которого равняется длине двух проекций вектора $l$ на $n$:

\begin{equation}
	\label{reflect_ray}
	R = l - 2 n \cdot \frac{(l, n)}{(n, n)}
\end{equation}

\clearpage
\section{Функциональная модель программного обеспечения}
На рисунках~\ref{img:1_idef0}-\ref{img:2_idef0} представлена функциональная модель программного обеспечения в нотации IDEF0.

\FloatBarrier
\imgw{0.9\textwidth}{1_idef0}{Функциональная модель программы в нотации IDEF0, уровень 0}
\FloatBarrier
\imgw{0.9\textwidth}{2_idef0}{Функциональная модель программы в нотации IDEF0, уровень 1}
\FloatBarrier

\clearpage
\section{Описание алгоритма обратной трассировки лучей}
На рисунках~\ref{img:ray_tracing.pdf}-~\ref{img:castRay.pdf} представлены схемы алгоритма испускания луча и алгоритма обратной трассировки лучей.
\FloatBarrier
\imgh{0.6\textheight}{ray_tracing.pdf}{Схема алгоритма обратной трассировки лучей}
\FloatBarrier
\imgh{0.9\textheight}{castRay.pdf}{Схема алгоритма испускания луча}
\FloatBarrier


\clearpage
\section{Структура разрабатываемого программного обеспечения}
\subsection{Диаграмма классов}
На рисунках~\ref{img:facade}-~\ref{img:loadManager} представлена диаграмма классов разрабатываемого программного обеспечения.
\FloatBarrier
\imgw{0.9\textwidth}{facade}{Диаграмма классов}
\FloatBarrier
\imgw{1\textwidth}{sceneManager}{Диаграмма классов}
\FloatBarrier
\imgw{1\textwidth}{loadManager}{Диаграмма классов}
\FloatBarrier

\subsection{Описание классов используемых в программе}
\begin{itemize}
	\item \textbf{FacadeScene} -- класс реализующий структурный паттерн <<фасад>>. Предоставляет графическому интерфейсу пользователя унифицированный интерфейс к програмному обеспечению, реализующему взаимодействие со сценой и отрисовку кадра, с помощью паттерна <<команда>>;
	\item \textbf{BaseCommand} -- базовый класс реализующий поведенческий паттерн <<команда>>. Инкапсулировует запрос пользователся на выполнение действия в виде отдельного объекта. В программе также реализовано несколько классов производных от данного, которые отвечают за каждый запрос пользователя по отдельности;
	\item \textbf{DrawManager} -- класс реализующий операцию отрисовки сцены;
	\item \textbf{RayTracing} -- класс реализующий поведенческий паттерн <<стратегия>>. Определяет реализацию алгоритма обратной трассировки лучей;
	\item \textbf{Drawer} -- базовый класс реализующий структурный паттерн <<адаптер>>. Определяет операцию закрашивания пикселей;
	\item \textbf{QtDrawer} -- производный класс от Drawer. Преобразует интерфейс класса QGraphic Viewr библиотеки Qt.
	\item \textbf{MaterialManager} -- класс реализующий взаимодействие с множеством материалов;
	\item \textbf{MaterialSolution} -- класс определяющих множество возможных материалов которые могут быть использованы в программе;
	\item \textbf{TransformManager} -- класс реализующий операции проеобразования обьектов сцены;
	\item \textbf{TransformAction} -- базовый класс реализующий поведенческий паттерн <<стратегия>>. Определяет алгоритм проеобразования обьектов сцены;
	\item \textbf{MoveAction} -- производный класс от TransformAction. Определяет алгоритм переноса обьектов сцены;
	\item \textbf{RotateAction} -- производный класс от TransformAction. Определяет алгоритм вращения обьектов сцены;
	\item \textbf{SceneManager} -- класс реализующий взаимодействие с обьектами сцены;
	\item \textbf{Scene} -- класс сцены. Хранит информацию об объектах сцены;
	\item \textbf{Camera} -- класс камеры. Хранит информацию о наблюдателе и реализует операцию создания луча;
	\item \textbf{Ray} -- класс луча. Хранит информацию о начальной точке и векторе направления луча;
	\item \textbf{Model} -- базовый класс фигуры, фигуры которая может быть изображена на сцене;
	\item \textbf{VolumeModel} -- производный класс от Model, является элеиментом абстракции структурного паттерна <<мост>>;
	\item \textbf{VolumeModelImpl} -- базовый класс являющийся элеиментом реализации структурного паттерна <<мост>>;
	\item \textbf{TrianglesModel} -- производный класс от VolumeModelImpl, определяет структуру трехмерной модели, как множество вершин и множество треугольных полигонов;
	\item \textbf{Triangle} -- класс описывающий треугольный полигон и операции над ним;
	\item \textbf{Chessboard} -- класс фигуры шахматной доски, реализующий структурный паттерн <<компоновщик>>. Шахматная доска состоит из трех моделей: модели определяющей деревянную основу доски и двух моделей определяющих множества черных и белых клеток;
	\item \textbf{LoadManager} -- класс реализующий загрузку моделей;
	\item \textbf{ReaderSolution} -- класс опрелеляющий используемый метод чтения файла;
	\item \textbf{BaseReaderCreator} -- базовый класс реализующий порождающий паттерн <<фабричный метод>>. Опреляет реализацию класса Reader, которая будет создана;
	\item \textbf{ReaderCreator} -- производный класс от BaseReaderCreator;
	\item \textbf{Reader} -- базовый класс реализующий операцию чтения из файла;
	\item \textbf{DataChessboardReader} -- производный класс от Reader. Определяет чтение из файла информации о шахматной доске;
	\item \textbf{VolumeModelReader} -- базовый класс определяющий операцию чтения информации о трехмерной модели;
	\item \textbf{TrianglesModelReader} -- производный класс от VolumeModelReader. Определяет чтение из файла информации о трехмерной модели, представленной классом TrianglesModel;
	\item \textbf{DirectorSolution} -- класс опрелеляющий используемый метод создания Model;
	\item \textbf{BaseDirectorCreator} -- базовый класс реализующий порождающий паттерн <<фабричный метод>>. Опреляет реализацию класса Director, которая будет создана;
	\item \textbf{DirectorCreator} -- производный класс от BaseDirectorCreator;
	\item \textbf{Director} -- базовый класс реализующий порождающий паттерн <<строитель>>, элемент <<director>>. Опредеяет перацию создания фигуры (Model);
	\item \textbf{ChessboardDirector} -- производный класс от Director. Определяет операцию создания класса шахматной доски (Chessboard);
	\item \textbf{VolumeModelDirector} -- базовый класс определяющий операцию создания класса модели (Model);
	\item \textbf{TrianglesModelDirector} -- производный класс от VolumeModelDirector. Определяет операцию создания класса трехмерной модели представленной классом TrianglesModel;
	\item \textbf{VolumeModelBuilder} -- базовый класс реализующий порождающий паттерн <<строитель>>, элемент <<builder>>. Опредеяет множество операций необходимых для создания фигуры (Model);
	\item \textbf{TrianglesModelBuilder} -- производный класс от VolumeModelBuilder. Опредеяет множество операций необходимых для создания фигуры, представленной классом TrianglesModel;	
\end{itemize}

%\section{Требования к программному обеспечению}

\clearpage
\section*{Вывод из конструкторской частьи}
В данном разделе были представлены математические основы алгоритма обратной трассировки лучей и спроектировано програмное обеспечение, которое было описано функциональной моделю, схемой алгоритма обратной трассировки лучей и структурой, представленной в виде диаграммы классов.

\clearpage
