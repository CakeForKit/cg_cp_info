\chapter{Конструкторская часть}

В данном разделе представлены математические основы и схема алгоритма обратной трассировки лучей, функциональная модель и структура программного обеспечения. 
%Так же будут описаны используемые структуры данных и структура реализуемого программного обеспечения.


\section{Математические основы алгоритма обратной трассировки лучей}
\subsection{Определение пересечения луча с полигоном}
Так как любую плоскость можно однозначно задать тремя точками, для поиска пересечения луча с полигонами используется алгоритм Моллера~--~Трумбора~\cite{trIntersect}, с помощью которого можно вычислить пересечение луча с треугольным полигоном.

Пусть треугольный полигон определен вершинами $V_0, V_1, V_2$, а луч $R(t)$ с началом в точке $O$ и единичным  вектором направления $D$ определен формулой
\begin{equation}
	R(t) = O + tD
\end{equation}

И если точку $T(u,v)$ на треугольнике $V_0V_1V_2$ выразить через ее барицентрические координаты $(u,v)$, так что ($u \geq 0, v \geq 0, u + v \leq 1$):
\begin{equation}
	T(u,v) = (1 - u - v)V_0 + uV_1 + vV_2,
\end{equation}
тогда пересечение луча $R(t)$ и треугольника $V_0V_1V_2$ эквивалентно решению уравнения
$R(t) = T(u, v)$ и однозначно определяются параметрами расстояния $t$ от начала луча до точки пересечения и барицентрическими координатами $(u,v)$. В таком случае получим:
\begin{equation}\label{eq:eq1}
	O + tD = (1- u - v)V_0 + uV_1 + vV_2
\end{equation}

Уравнение~\ref{eq:eq1} может быть представлено в матричном виде:
\begin{equation}
	\label{slau}
	\begin{bmatrix}
		-D & V_1 - V_0, V_2 - V_0
	\end{bmatrix}
	\begin{bmatrix}
		t\\
		u\\
		v
	\end{bmatrix} = O - V_0 
\end{equation}

Пусть $E_1 = V_1 - V_0, E_2 = V_2 - V_0$, $T=O - V_0$. Решение уравнения~\ref{eq:eq1} можно получить методом Крамера:
\begin{equation}\label{eq:eq2}
	\begin{bmatrix}
		t\\
		u\\
		v
	\end{bmatrix} = \frac{1}{(D\times E_2) \cdot E_1}
	\begin{bmatrix}
		(T\times E_1) \cdot E_2\\
		(D\times E_2) \cdot T\\
		(T\times E_1) \cdot D
	\end{bmatrix}
\end{equation}
 
Если барицентрические координаты точки пересечения, полученной из формулы~\ref{eq:eq2} удовлетворяют условию ($u \geq 0, v \geq 0, u + v \leq 1$), то луч $R(t)$ пересекает треугольный полигон заданный вершинами $V_0, V_1, V_2$. Если определитель $(D\times E_2) \cdot E_1$ равен нулю, то луч лежит в плоскости треугольника $V_0V_1V_2$.


%\subsection{Определение нормали к плоскости}
%Нормаль к плоскости можно найти как векторное произведение двух векторов, принадлежащих данной плоскости~\cite{rodgersCG}:
%
%Для поиска нормали к полигонам необходимо найти векторное произведение двух векторов, которые лежат на полигоне \cite{rodgers}.
%\begin{equation}
%	N = (V_2 - V_0) \times (V_1 - V_0),
%\end{equation}
%где $V_0, V_1, V_2$ -- вершины полигона.

\subsection{Определение вектора отражения}

Для визуализации отражающих поверхностей в алгоритме обратной трассировки лучей необходим способ определения направления вектора отражения зная луч падения~$l$ и нормаль к поверхности~$n$~\cite{rtOneWeekend}.

\imgw{0.4\textwidth}{reflect}{Расчет направления вектора отражения}

Вектор отражения представляется через разность вектора падения $l$ и вектора нормали $n$, длина которого равняется длине двух проекций вектора $l$ на $n$:

\begin{equation}
	\label{reflect_ray}
	r = l - 2 n \cdot \frac{(l, n)}{(n, n)}
\end{equation}

\clearpage
\section{Функциональная модель программного обеспечения}

Разрабатываемое программное обеспечение должно генерировать кадр на основе информации о положении в пространстве объектов сцены, интенсивности источника света, вектора направления камеры и множестве полигонов, которыми заданы модели фигур. Для создания изображения программное обеспечение использует алгоритмы испускания луча и обратной трассировки луча, которые заключаются испускании луча для каждого пикселя и вычислении цвета этого пикселя.

На рисунках~\ref{img:1_idef0}-\ref{img:2_idef0} представлена функциональная модель программного обеспечения в нотации IDEF0.

\FloatBarrier
\imgw{0.9\textwidth}{1_idef0}{Функциональная модель программы в нотации IDEF0, уровень 0}
\FloatBarrier
\imgw{0.9\textwidth}{2_idef0}{Функциональная модель программы в нотации IDEF0, уровень 1}
\FloatBarrier

\clearpage
\section{Описание алгоритма определения цвета пикселя, методом обратной трассировки лучей}

Для генерации кадра сцены алгоритмом обратной трассировки лучей необходимо для каждого пикселя изображения вычислить его цвет, с использованием алгоритма трассировки луча, который представлен на рисунках~\ref{img:castRay1.pdf}-\ref{img:castRay2.pdf}. Данный алгоритм для каждого луча исходящего от наблюдателя и проходящего через центр пикселя вычисляет цвет этого пикселя на основе положения моделей сцены, их материалов и источника света.
%На рисунке~\ref{img:castRay.pdf} представлена схема алгоритма трассировки луча.

\FloatBarrier
\imgw{0.7\textwidth}{castRay1.pdf}{Схема алгоритма трассировки луча}
\FloatBarrier
\imgw{0.7\textwidth}{castRay2.pdf}{Схема алгоритма трассировки луча}
\FloatBarrier

\clearpage
\section{Структура разрабатываемого программного обеспечения}

При разработке программного обеспечения использовался объектно-ориентированный подход и паттерны проектирования, для улучшения декомпозиции задачи и облегчения модификаций кода.

На рисунках~\ref{img:facade}-\ref{img:loadManager} представлена диаграмма классов разрабатываемого программного обеспечения.
\FloatBarrier
\imgw{0.8\textwidth}{facade}{Диаграмма классов, которые реализуют доступ графическому интерфейсу пользователя к программному обеспечению}
\FloatBarrier

\begin{itemize}
	\item \textbf{FacadeScene} -- класс, реализующий структурный паттерн <<фасад>>. Предоставляет графическому интерфейсу пользователя унифицированный интерфейс к программному обеспечению, реализующему взаимодействие со сценой и отрисовку кадра, с помощью паттерна <<команда>>;
	\item \textbf{BaseCommand} -- базовый класс, реализующий поведенческий паттерн <<команда>>. Инкапсулирует запрос пользователя на выполнение действия в виде отдельного объекта. В программе также реализовано несколько классов производных от данного, которые отвечают за каждый запрос пользователя по отдельности;
	\item \textbf{DrawManager} -- класс, реализующий операцию отрисовки сцены;
	\item \textbf{RayTracing} -- класс, реализующий поведенческий паттерн <<стратегия>>. Определяет реализацию алгоритма обратной трассировки лучей;
	\item \textbf{Drawer} -- базовый класс, реализующий структурный паттерн <<адаптер>>. Определяет операцию закрашивания пикселей;
	\item \textbf{QtDrawer} -- производный класс от Drawer. Преобразует интерфейс класса QGraphicViewer библиотеки Qt.
	\item \textbf{MaterialManager} -- класс, реализующий взаимодействие со множеством материалов;
	\item \textbf{MaterialSolution} -- класс, определяющий множество возможных материалов, которые могут быть использованы в программе;
	\item \textbf{TransformManager} -- класс, реализующий операции преобразования объектов сцены;
	\item \textbf{TransformAction} -- базовый класс, реализующий поведенческий паттерн <<стратегия>>. Определяет алгоритм преобразования объектов сцены;
	\item \textbf{MoveAction} -- производный класс от TransformAction. Определяет алгоритм переноса объектов сцены;
	\item \textbf{RotateAction} -- производный класс от TransformAction. Определяет алгоритм вращения объектов сцены;
\end{itemize}

\FloatBarrier
\imgw{1\textwidth}{sceneManager}{Диаграмма классов, описывающих обьекты сцены}
\FloatBarrier

\begin{itemize}
	\item \textbf{SceneManager} -- класс, реализующий взаимодействие с объектами сцены;
	\item \textbf{Scene} -- класс сцены. Хранит информацию об объектах сцены;
	\item \textbf{Camera} -- класс камеры. Хранит информацию о наблюдателе и реализует операцию создания луча;
	\item \textbf{Ray} -- класс луча. Хранит информацию о начальной точке и векторе направления луча;
	\item \textbf{Model} -- базовый класс фигуры, которая может быть изображена на сцене;
	\item \textbf{VolumeModel} -- производный класс от Model, является элементом абстракции структурного паттерна <<мост>>;
	\item \textbf{VolumeModelImpl} -- базовый класс, являющийся элементом реализации структурного паттерна <<мост>>;
	\item \textbf{TrianglesModel} -- производный класс от VolumeModelImpl, определяет структуру трехмерной модели, как множество вершин и множество треугольных полигонов;
	\item \textbf{Triangle} -- класс, описывающий треугольный полигон и операции над ним;
	\item \textbf{Chessboard} -- класс фигуры шахматной доски, реализующий структурный паттерн <<компоновщик>>. Шахматная доска состоит из трех моделей: модели определяющей деревянную основу доски и двух моделей определяющих множества черных и белых клеток;
\end{itemize}

\FloatBarrier
\imgw{1\textwidth}{loadManager}{Диаграмма классов, которые реализуют загрузку моделей фигур на сцену}
\FloatBarrier

%\subsection{Описание классов, используемых в программе}
\begin{itemize}
	\item \textbf{LoadManager} -- класс, реализующий загрузку моделей;
	\item \textbf{ReaderSolution} -- класс, определяющий используемый метод чтения файла;
	\item \textbf{BaseReaderCreator} -- базовый класс, реализующий порождающий паттерн <<фабричный метод>>. Определяет реализацию класса Reader, которая будет создана;
	\item \textbf{ReaderCreator} -- производный класс от BaseReaderCreator;
	\item \textbf{Reader} -- базовый класс, реализующий операцию чтения из файла;
	\item \textbf{DataChessboardReader} -- производный класс от Reader. Определяет чтение из файла информации о шахматной доске;
	\item \textbf{VolumeModelReader} -- базовый класс, определяющий операцию чтения информации о трехмерной модели;
	\item \textbf{TrianglesModelReader} -- производный класс от VolumeModelReader. Определяет чтение из файла информации о трехмерной модели, представленной классом TrianglesModel;
	\item \textbf{DirectorSolution} -- класс, определяющий используемый метод создания Model;
	\item \textbf{BaseDirectorCreator} -- базовый класс, реализующий порождающий паттерн <<фабричный метод>>. Определяет реализацию класса Director, которая будет создана;
	\item \textbf{DirectorCreator} -- производный класс от BaseDirectorCreator;
	\item \textbf{Director} -- базовый класс, реализующий порождающий паттерн <<строитель>>, элемент <<director>>. Определяет операцию создания фигуры (Model);
	\item \textbf{ChessboardDirector} -- производный класс от Director. Определяет операцию создания класса шахматной доски (Chessboard);
	\item \textbf{VolumeModelDirector} -- базовый класс, определяющий операцию создания класса модели (Model);
	\item \textbf{TrianglesModelDirector} -- производный класс от VolumeModelDirector. Определяет операцию создания класса трехмерной модели, представленной классом TrianglesModel;
	\item \textbf{VolumeModelBuilder} -- базовый класс, реализующий порождающий паттерн <<строитель>>, элемент <<builder>>. Определяет множество операций необходимых для создания фигуры (Model);
	\item \textbf{TrianglesModelBuilder} -- производный класс от VolumeModelBuilder. Определяет множество операций необходимых для создания фигуры, представленной классом TrianglesModel;	
\end{itemize}

%\section{Требования к программному обеспечению}

%\clearpage
\section*{Вывод из конструкторской части}
В данном разделе были представлены математические основы алгоритма обратной трассировки лучей и спроектировано программное обеспечение, которое было описано функциональной моделью, схемой алгоритма обратной трассировки лучей и структурой, представленной в виде диаграммы классов.

\clearpage
